# Singleton(싱글톤)

-   하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
-   데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등에 많이 쓰임
-   생성자 호출은 반드시 새 객체를 반환하기 때문에 일반 생성자로 구현할 수 없다.
    -   new 연산자를 사용하지 못하도록 default constructor를 private로 설정한다.
    -   생성자 역할을 하는 static 메서드를 사용한다.
-   다른 클래스의 인스턴스들이 데이터를 공유할 수 있다.
-   인스턴스가 절대적으로 한개만 존재하는 것을 보증할 수 있다.
-   어떤 클래스를 **최초 한번만 메모리에 할당**하여 사용할 수 있다.
-   각 테스트마다 ‘독립적인’ 인스턴스를 만들기 어려워 TDD가 불편하다는 단점이 있다.
-   의존성이 높아진다(모듈간의 결합↑, Coupling↑)
    -   의존성 주입(DI, Dependency Injection)을 통해 모듈간의 결합을 조금 느슨하게 만들 수 있다.
    -   의존성 주입을 사용하면 모듈들을 쉽게 교체할 수 있어 테스팅하기 쉽고 마이그레이션하기도 수월하다.
    -   의존성 주입을 하면 모듈들이 더욱 더 분리되어 복잡성이 증가될 수 있고, 약간의 런타임 페널티가 생긴다.
-   상태를 가진 객체를 Singleton으로 만들면 안된다.

-   **7가지 구현 방법**
    1. 단순 메서드 호출로 구현
        - 메서드의 원자성이 결여되어있다.
        - 멀티스레드 환경X
    2. synchronized 키워드 사용
        - 메서드를 동시에 호출할 수 없지만, lock이 걸려 성능이 저하된다.
    3. static member 사용
        - 런타임이 아니라 클래스가 로딩되는 시점에 미리 인스턴스를 생성
        - 싱글톤 인스턴스가 필요없는 경우에도 무조건 생성되어 메모리 낭비 발생
    4. static block 사용
    5. 내부 클래스(Holder) 사용
        - getInstance() 메서드가 호출될 때 Holder 클래스가 로딩되어 인스턴스를 생성한다.
        - 메모리 낭비 문제가 발생하지 않는다.
    6. DCL(Double Checked Locking) 사용
        - 메서드를 호출할 때마다 lock이 걸려 성능이 저하되는 문제를 해결하기 위함
        - 2번 체크를 한다.(2번째 체크때는 synchronized)
    7. Enum 사용
        - enum의 인스턴스는 기본적으로 thread-safe가 보장된다.
        - A single-element enum type is the best way to implement a singleton
            - (Joshua Bloch, Effective Java 2nd Edition p.18)
