# Decorate(데코레이터)

-   주어진 상황, 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로 기능 확장이 필요할 때 서브 클래스 대신 쓸 수 있는 유용한 대안이 될 수 있다.
-   구조
    -   Component : 데코레이터 패턴에서 기본 기능을 정의한 인터페이스 또는 추상 클래스
    -   ConcreteComponent : Component 인터페이스를 구현한 구체적인 클래스. 데코레이션할 대상(디폴트)
    -   Decorator : Component 인터페이스를 구현하고, Component 객체를 감싸는 데코레이터 클래스
        -   데코레이터 클래스는 새로운 기능을 추가하거나 기존 기능을 수정한다.
        -   데코레이터를 데코레이트 할 수 있다.(Component를 상속받으면서, Component를 상속받는 모든 것을 데코레이트)
    -   ConcreteDecorator : Decorator 클래스를 상속받아 실제로 새로운 기능을 추가하는 클래스
-   같은 클래스의 다른 객체 동작에 영향을 주지 않고 **개별 객체에 동작을 동적으로 추가**할 수 있는 디자인 패턴
-   객체들을 새로운 행동들을 포함한 특수 래퍼 객체에 넣어서 위 행동들을 해당 객체에 연결시키는 디자인 패턴
    -   새로운 객체를 정의하지 않고도 객체의 동작을 보강할 수 있기 때문에 서브 클래싱보다 효율적일 수 있다.
-   객체의 동작을 변경할 때 가장 먼저 떠올릴 수 있는 대안은 클래스 확장(상속)
    -   상속의 문제 1) 상속은 정적 : 런타임 시 기존 객체의 동작을 바꿀 수 없다.
    -   상속의 문제 2) 하위 클래스는 하나의 상위 클래스만 가질 수 있다.
    -   데코레이터 패턴은 객체에 유연한 추가 책임을 동적으로 첨부한다.
    -   기능 확장을 위해 상속 대신 구성(composition)을 사용한다.(Wrapper)
-   개방/폐쇠 원칙 : 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있다.
-   객체간의 결합도가 낮아져 유지보수성과 확장성이 높아진다.
-   클래스 수가 증가해 프로그램의 복잡성이 증가할 수 있다.
-   여러 데코레이터를 조합하면 객체의 동작을 예측하기 어려울 수 있다.
